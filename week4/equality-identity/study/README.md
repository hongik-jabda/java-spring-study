## 동등성과 동일성

### 동일성(Identity)

- 두 객체가 동일한 메모리 주소를 가리키는지 나타냄(참조 타입의 변수에서)
- 즉, 두 객체가 완전히 같은 객체인지를 비교하는 것
- 객체의 상태가 완전히 같아도, 주소 공간이 다르면 동일한 객체가 아님
- 자바에서는 `==` 연산자를 사용하여 동일성을 비교

```java
String a = "Hello";
String b = "Hello";
System.out.println(a == b); // true, 왜냐면 둘 다 같은 메모리 주소를 가리킴
```

`String` 이 참조 타입이지만, 문자열 리터럴이 문자열 상수 풀에 저장되기 때문에 동일한 문자열 리터럴을 사용할 경우 같은 객체를 참조하여 `a == b` 는 두 참조가 동일한 객체를 가리키므로 `true` 를 반환한다.

- 원시 타입과 참조 타입
    1. **원시 타입(Primitive Type)**
        - 가장 기본적인 데이터 타입으로, 더 이상 쪼갤 수 없는 단위
        - `byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean` 등
        - 변수 자체가 실제 값을 저장함
        - `int a = 3;` 과 `int b = 3;` 는 각각 메모리의 다른 위치에 3이라는 값을 저장함
        - 즉 a와 b는 메모리에서 서로 다른 위치에 저장된 3을 담고 있음
        - 원시 타입에서 `==` 연산자는 값 자체를 비교
        - 두 변수 값이 모두 3 이므로 `a == b` 는 true를 반환
    2. **참조 타입(Reference Type)**
        - `String`, `배열`, `사용자 정의 클래스` 등에 해당
        - 변수는 객체가 저장된 메모리 위치(주소)를 저장함
        - 참조 타입에서 `==` 연산자는 객체의 메모리 주소를 비교
        - 예를 들어, `String a = "Hello";` 와 `String b = "Hello";` 는 문자열 상수 풀에서 동일한 `“Hello”`객체의 주소를 저장함


### 동등성 (Equality)

- 두 객체의 내용이 같은지를 나타냄
- **논리적으로 같은 지위를 지녔는지** 확인 → 기준이 필요
- 논리적 동등성의 기준은 개발자가 재정의해야함
- 자바에서는 `equals()` 메서드를 사용해 동등성을 비교

```java
String c = new String("hello");
String d = new String("hello");
System.out.println(c == d); // false
System.out.println(c.equals(d)); // true, 왜냐면 두 객체의 내용이 같아서
```

new String을 통해 참조 타입으로 변수를 생성한 경우, 참조 타입은 주소 공간을 저장하므로 주소 공간이 다른 c와 d는 동일성이 보장되지 않고 동등성만 보장됨

String 클래스는 Object 클래스에서 상속받은 equals 메서드를 오버라이드하여 문자열의 내용을 비교하도록  구현되어 있음

## equals() 와 hashCode()

### equals()

- 객체의 동등성을 비교하기 위해 사용됨
- 기본적으로 `Object` 클래스에 정의되어 있으며, 필요한 경우 오버라이드해서 사용할 수 있음
- `equals()` 메서드를 오버라이드할 때는 두 객체의 특정 필드 값을 비교하도록 작성해야 함

### hashCode()

- `hashCode()` : 객체를 위한 고유한 정수값(해시코드)를 반환하는 메서드
- 해시 테이블 기반의 컬렉션인 `HashMap` ,`HashSet` 등이 객체를 빠르게 검색할 수 있도록 도움
- `equals`만 잘 재정의하면 모든 객체의 동등성이 보장될 것 같지만, 아쉽게도 모든 객체가 그렇지는 않음
- 이 예외는 hash 값을 사용하는 `Hash Collection` 자료구조 (HashMap, HashSet, HashTable) 때문에 일어남

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/14bc23a6-8ef2-4f06-80e4-252497aa3f34/d94ec2f6-fff7-44e6-bbbe-d6f6b26b921e/Untitled.png)

즉, `hsahCode` 값이 같아야만 `equals 메소드`로 객체 비교를 수행함.

`hashCode`가 다르면 동등성 비교는 입구컷

**따라서 상태 값이 같을 때, HashCode 또한 같도록 오버라이딩 해야함**

- 그러면 해시 자료구조를 쓰지 않을 때도 `hashCode()`를 오버라이드해야할까?

  → 해시 기반 컬렉션을 사용하지 않을 때는 필수적이지 않을 수 있지만, 몇 가지 이유로 오버라이드하는 것이 유용할 수 있음

    1. `Object`  클래스는 `equals()` 메서드를 오버라이드할 때 `hashCode()` 메서드도 오버라이드할 것을 요구함. → 이 계약에 따라, `equals()` 메서드로 같다고 판단되면, `hashCode()` 메서드도 **같은 해시코드를 반환**해야 함
    2. 해시코드가 올바르게 구현되어 있으면 코드가 더 직관적이 되어 디버깅할 때도 좋고 유지 보수 측면에서 좋음
    3. 현재는 해시 기반 컬렉션을 사용하지 않더라도, 나중에 쓸 수 있기 때문에 처음부터 올바르게 구현해 두는 것도 좋음

## 요약

1. **동일성 (Identity)** 비교는 `==` 를 통해 메모리 내 주소값이 같은지 비교하는 것
2. **동등성(Equality)** 비교는 `equals()` & `hashCode()` 를 통해 논리적 지위가 같은지 비교하는 것
3. `논리적 지위가 같다`의 기준은 **개발자가 요구사항에 맞게 오버라이드하여 재정의**해야함
4. `equals() 메소드`에선 “두 객체가 같다”의 기준이 될 필드들을 비교하도록 재정의
5. `hashCode() 메소드`에선 “두 객체가 같다”의 기준이 될 필드들의 값으로 hashCode를 만들도록 재정의